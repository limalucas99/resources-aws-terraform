name: Terraform Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  terraform:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./ 

    steps:
      # 1) Faz checkout do reposit√≥rio
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Configura credenciais AWS (para S3, Secrets Manager etc)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          aws-session-token: ${{ secrets.SESSION_TOKEN }}  # se voc√™ usar STS

      # 3) Instala jq para parse de JSON
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      # 4) Setup Terraform CLI
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3

      # 5) Terraform Init
      - name: Terraform Init
        run: terraform init -input=false

      # 6) Terraform Validate
      - name: Terraform Validate
        run: terraform validate

      ############################
      # 7) Baixar arquivo plan.tfplan do S3 (se j√° existir)
      #
      #    - Aqui assumimos que, no seu `terraform.tfvars`, 
      #      voc√™ j√° tem definido: bucket_name = "meu-bucket-aws-resources"
      #
      #    - No primeiro run, como o bucket ainda n√£o existe, esse comando ‚Äúfalhar√°‚Äù com 404
      #      e n√≥s capturamos isso para prosseguir sem erro. Nos runs subsequentes, 
      #      se existir plan.tfplan no bucket, ele ser√° baixado para ./plan.tfplan.
      #
      #    Padr√£o: usamos aws cli + exit code condicional para ‚Äúignorar‚Äù erro 404.
      ############################
      - name: Download existing Terraform Plan from S3
        id: download_plan
        run: |
          # Extrai bucket_name diretamente do terraform.tfvars:
          BUCKET_NAME=$(grep '^bucket_name' terraform.tfvars | head -n1 | awk -F'=' '{print $2}' | tr -d ' "')
          echo "üîç  Bucket configurado para armazenar o plano: $BUCKET_NAME"

          # Se n√£o existir bucket ou objeto, queremos continuar sem falhar.
          set +e
          aws s3 cp s3://"$BUCKET_NAME"/plan.tfplan ./plan.tfplan
          RET=$?
          set -e

          if [ $RET -eq 0 ]; then
            echo "‚úîÔ∏è  Encontrado plan.tfplan em s3://$BUCKET_NAME/plan.tfplan. Vai reaplicar o mesmo plano."
          else
            echo "‚ÑπÔ∏è  N√£o existe plan.tfplan em s3://$BUCKET_NAME/plan.tfplan. Ser√° gerado um novo."
          fi

      ############################
      # 8) Terraform Plan gerando um arquivo bin√°rio (plan.tfplan)
      #
      #    - Se j√° baixamos um plan.tfplan do S3, o Terraform 
      #      saber√° que o estado remoto corresponde ao plano antigo. 
      #    - Mesmo assim, rodamos `terraform plan -out=plan.tfplan` 
      #      para gerar o plano novo considerando eventuais mudan√ßas de c√≥digo.
      ############################
      - name: Terraform Plan (output para arquivo)
        run: terraform plan -out=plan.tfplan -input=false

      ############################
      # 9) Terraform Apply usando plan.tfplan
      #
      #    - Se falhar, executamos um rollback (destroy).
      #    - O m√≥dulo S3 ser√° criado neste momento, se ainda n√£o existir.
      ############################
      - name: Terraform Apply from Plan
        id: apply
        run: terraform apply -auto-approve plan.tfplan
        continue-on-error: true

      # 10) Rollback on Failure
      - name: Rollback on Failure
        if: steps.apply.outcome == 'failure'
        run: |
          echo "‚ùå Terraform Apply falhou. Executando terraform destroy como rollback..."
          terraform destroy -auto-approve
          exit 1

      ############################
      # 11) Extrair outputs do Terraform em JSON
      #
      #     - Gera um arquivo tf-outputs.json com todos os outputs declarados. 
      ############################
      - name: Terraform Output to JSON
        run: terraform output -json > tf-outputs.json

      ############################
      # 12) Carregar cada sa√≠da do Terraform no AWS Secrets Manager
      #
      #     - Para cada chave no JSON, fazemos:
      #         aws secretsmanager create-secret || aws secretsmanager put-secret-value
      #     - Nome do secret: <prefix>/<nome_da_chave>
      #     - Prefixo poderia ser uma vari√°vel ou simplesmente ‚Äúterraform‚Äù.
      #     - Usamos `jq` para iterar sobre as chaves do JSON.
      ############################
      - name: Publish Terraform Outputs to AWS Secrets Manager
        id: publish_secrets
        run: |
          PREFIX="terraform" 
          # Podemos parametrizar PREFIX se quiser mapear v√°rios ambientes.
          
          # L√™ o JSON de outputs
          for key in $(jq -r 'keys[]' tf-outputs.json); do
            value=$(jq -r ".\"$key\".value" tf-outputs.json)
            
            # Se o valor for um objeto ou array, convert√™-lo em string JSON
            if echo "$value" | jq -e . >/dev/null 2>&1; then
              secret_string="$value"
            else
              # se for string ‚Äúsimples‚Äù, n√£o precisa de aspas extras
              secret_string=$(printf '%s' "$value")
            fi
            
            SECRET_NAME="${PREFIX}/${key}"
            
            # Tenta criar o secret (caso n√£o exista)
            set +e
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --secret-string "$secret_string" \
              --region="${{ secrets.AWS_REGION }}"
            RET_CREATE=$?
            set -e
            
            if [ $RET_CREATE -eq 0 ]; then
              echo "‚úîÔ∏è  Secret '$SECRET_NAME' criado com sucesso."
            else
              # Se falhar porque j√° existe, fazemos update
              echo "‚ÑπÔ∏è  Secret '$SECRET_NAME' j√° existe. Atualizando valor..."
              aws secretsmanager put-secret-value \
                --secret-id "$SECRET_NAME" \
                --secret-string "$secret_string" \
                --region="${{ secrets.AWS_REGION }}"
              echo "‚úîÔ∏è  Secret '$SECRET_NAME' atualizado."
            fi
          done

      # 10) Rollback on Failure
      - name: Rollback on Failure
        if: steps.apply.outcome == 'failure'
        run: |
          echo "‚ùå Terraform Apply falhou. Executando terraform destroy como rollback..."
          terraform destroy -auto-approve
          exit 1

      ############################
      # 13) Fazer upload do plan.tfplan gerado para o bucket S3
      #
      #     - Agora que o bucket S3 (m√≥dulo Terraform) j√° existe
      #       (criado no passo de apply), podemos armazenar Add commentMore actions
      #       plan.tfplan em s3://<bucket_name>/plan.tfplan
      ############################
      - name: Upload Terraform Plan to S3
        if: steps.apply.outcome == 'success'
        run: |
          # Extrai bucket_name do tf-outputs.json
          BUCKET_NAME=$(jq -r '.bucket_name.value' tf-outputs.json)
          echo "üîí  Fazendo upload do plan.tfplan para s3://$BUCKET_NAME/plan.tfplan"
          aws s3 cp plan.tfplan s3://"$BUCKET_NAME"/plan.tfplan \
            --region="${{ secrets.AWS_REGION }}"