name: Terraform Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  terraform:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./

    steps:
      # 1) Faz checkout do reposit√≥rio
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2) Configura credenciais AWS (para S3, Secrets Manager, backend Terraform etc)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}
          aws-session-token:     ${{ secrets.SESSION_TOKEN }}

      # 3) Instala jq (para parse de JSON)
      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      # 4) Setup Terraform CLI (com backend remoto configurado em main.tf ou providers.tf)
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3

      # 5) Terraform Init (garante que o backend remoto seja inicializado)
      - name: Terraform Init
        run: terraform init -input=false

      # 6) Terraform Validate (confere sintaxe e estrutura HCL)
      - name: Terraform Validate
        run: terraform validate

      ############################
      # 7) Terraform Plan (gera um novo arquivo plan.tfplan)
      #
      #    - SEM nenhum download de plano antigo.
      #    - Isso faz com que o Terraform consulte o estado remoto (via backend) 
      #      e gere um plano atualizado, refletindo todos os recursos existentes.
      ############################
      - name: Terraform Plan (output para arquivo)
        id: terraform_plan
        run: terraform plan -out=plan.tfplan -input=false

      ############################
      # 8) Terraform Apply usando o plan.tfplan gerado
      #
      #    - Garante que aplicamos exatamente o que foi calculado no passo anterior.
      #    - Se falhar, fazemos rollback (destroy).
      ############################
      - name: Terraform Apply from Plan
        id: apply
        run: terraform apply -auto-approve plan.tfplan
        continue-on-error: true

      # 9) Rollback on Failure (somente se apply falhar)
      - name: Rollback on Failure
        if: steps.apply.outcome == 'failure'
        run: |
          echo "‚ùå Terraform Apply falhou. Executando terraform destroy como rollback..."
          terraform destroy -auto-approve
          exit 1

      ############################
      # 10) Extrair outputs do Terraform em JSON
      #
      #     - Gera tf-outputs.json com TODOS os outputs que voc√™ declarou 
      #       em seus m√≥dulos/main.tf.
      ############################
      - name: Terraform Output to JSON
        run: terraform output -json > tf-outputs.json

      ############################
      # 11) Publicar cada sa√≠da do Terraform no AWS Secrets Manager
      #
      #     - Itera sobre as chaves do tf-outputs.json e faz create || put no Secrets Manager.
      #     - O nome de cada secret ser√°: "terraform/<nome_do_output>"
      ############################
      - name: Publish Terraform Outputs to AWS Secrets Manager
        id: publish_secrets
        run: |
          PREFIX="terraform"
          for key in $(jq -r 'keys[]' tf-outputs.json); do
            # Pega o valor bruto de cada output
            raw_value=$(jq -r ".\"$key\".value" tf-outputs.json)

            # Verifica se o valor √© JSON v√°lido (objeto/array); sen√£o, trata como string simples
            if echo "$raw_value" | jq -e . >/dev/null 2>&1; then
              secret_string="$raw_value"
            else
              # Valores simples (string, n√∫mero) s√£o usados "crus"
              secret_string=$(printf '%s' "$raw_value")
            fi

            SECRET_NAME="${PREFIX}/${key}"

            # Tenta criar o secret. Se j√° existir, atualiza.
            set +e
            aws secretsmanager create-secret \
              --name "$SECRET_NAME" \
              --secret-string "$secret_string" \
              --region="${{ secrets.AWS_REGION }}"
            RET_CREATE=$?
            set -e

            if [ $RET_CREATE -eq 0 ]; then
              echo "‚úîÔ∏è  Secret '$SECRET_NAME' criado com sucesso."
            else
              echo "‚ÑπÔ∏è  Secret '$SECRET_NAME' j√° existe. Atualizando valor..."
              aws secretsmanager put-secret-value \
                --secret-id "$SECRET_NAME" \
                --secret-string "$secret_string" \
                --region="${{ secrets.AWS_REGION }}"
              echo "‚úîÔ∏è  Secret '$SECRET_NAME' atualizado."
            fi
          done

      ############################
      # 12) Fazer upload do arquivo plan.tfplan para o bucket S3 criado pelo Terraform
      #
      #     - Isso ocorre somente SE o apply tiver sido bem-sucedido.
      #     - O bucket S3 deve ter sido criado dentro do Terraform (m√≥dulo s3 em main.tf).
      #     - O nome do bucket √© obtido do output "bucket_name" do Terraform.
      ############################
      - name: Upload Terraform Plan to S3
        if: steps.apply.outcome == 'success'
        run: |
          # Pega o "bucket_name" do JSON de outputs
          BUCKET_NAME=$(jq -r '.bucket_name.value' tf-outputs.json)
          echo "üîí  Fazendo upload do plan.tfplan em s3://$BUCKET_NAME/plan.tfplan"
          aws s3 cp plan.tfplan s3://"$BUCKET_NAME"/plan.tfplan \
            --region="${{ secrets.AWS_REGION }}"
